<!DOCTYPE html>
<meta charset=utf-8>
<title>Web NFC: NDEFWriter.push Tests</title>
<link rel="author" title="Intel" href="http://www.intel.com"/>
<link rel="help" href="https://w3c.github.io/web-nfc/"/>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/nfc-helpers.js"></script>
<script>

"use strict";

const invalid_type_messages =
    [
      // Invalid NDEFMessageSource type
      undefined,

      // NDEFMessage.records: should have at least 1 valid record.
      // https://w3c.github.io/web-nfc/#the-push-method - Step 8.
      createMessage([{}]),

      // NDEFMessageSource: not NDEF-formatable.
      // https://w3c.github.io/web-nfc/#the-push-method - Step 8.
      createMessage([]),

      // https://w3c.github.io/web-nfc/#dfn-map-text-to-ndef
      // NDEFRecord must have data.
      createMessage([createTextRecord()]),

      // NDEFRecord.data for 'text' record must be either a string,
      // an arrayBuffer, or an arrayBufferView.
      createMessage([createTextRecord(test_json_data)]),
      createMessage([createTextRecord(test_number_data)]),

      // NDEFRecord.encoding for 'text' record must be either "utf-8",
      // "utf-16", "utf-16le" or "utf-16be".
      createMessage([createTextRecord(test_text_data, "chinese")]),

      // NDEFRecord.lang length for 'text' record must be lower than 64.
      createMessage([createTextRecord(test_text_data, undefined /* encoding */, [...Array(64)].map(_ => 'a'))]),

      // https://w3c.github.io/web-nfc/#dfn-map-a-url-to-ndef
      // NDEFRecord must have data.
      createMessage([createUrlRecord()]),

      // https://w3c.github.io/web-nfc/#dfn-map-a-url-to-ndef
      // NDEFRecord must have data.
      createMessage([createUrlRecord(undefined, true)]),

      // NDEFRecord.data for 'url' record must be string.
      createMessage([createUrlRecord(test_buffer_data)]),
      createMessage([createUrlRecord(test_number_data)]),
      createMessage([createUrlRecord(test_json_data)]),

      // NDEFRecord.data for 'absolute-url' record must be string.
      createMessage([createUrlRecord(test_buffer_data, true)]),
      createMessage([createUrlRecord(test_number_data, true)]),
      createMessage([createUrlRecord(test_json_data, true)]),

      // https://w3c.github.io/web-nfc/#dfn-map-binary-data-to-ndef
      // NDEFRecord must have data.
      createMessage([createMimeRecord()]),

      // NDEFRecord.data for 'mime' record must be BufferSource.
      createMessage([createMimeRecord(test_text_data)]),
      createMessage([createMimeRecord(test_number_data)]),
      createMessage([createMimeRecord(test_json_data)]),

      // NDEFRecord must have data.
      createMessage([createUnknownRecord()]),

      // NDEFRecord.data for 'unknown' record must be BufferSource.
      createMessage([createUnknownRecord(test_text_data)]),
      createMessage([createUnknownRecord(test_number_data)]),
      createMessage([createUnknownRecord(test_json_data)]),

      // https://w3c.github.io/web-nfc/#dfn-map-external-data-to-ndef
      // NDEFRecord must have data.
      createMessage([createRecord('w3.org:xyz')]),

      // NDEFRecord.data for external record must be ArrayBuffer.
      createMessage([createRecord('w3.org:xyz', test_text_data)]),
      createMessage([createRecord('w3.org:xyz', test_number_data)]),
      createMessage([createRecord('w3.org:xyz', test_json_data)]),

      // https://w3c.github.io/web-nfc/#the-ndefrecordtype-string
      // The record type is neither a known type ('text', 'mime' etc.) nor a
      // valid custom type for an external type record.
      createMessage([createRecord('unmatched_type', test_buffer_data)])
    ];

const invalid_syntax_messages =
    [
      // Data for 'url' or 'absolute-url' record, must be a valid URL.
      createMessage([createUrlRecord('Invalid URL:// Data')]),
      createMessage([createUrlRecord('Invalid URL:// Data', true)]),
    ];

const invalid_signals = [
  "string",
  123,
  {},
  true,
  Symbol(),
  () => {},
  self
];

promise_test(async t => {
  const writer = new NDEFWriter();
  const promises = [];
  invalid_type_messages.forEach(message => {
    promises.push(
      promise_rejects(t, new TypeError(), writer.push(message)));
  });
  await Promise.all(promises);
}, "Test that promise is rejected with TypeError if NDEFMessageSource is invalid.");

promise_test(async t => {
  const writer = new NDEFWriter();
  const promises = [];
  invalid_syntax_messages.forEach(message => {
    promises.push(
      promise_rejects(t, 'SyntaxError', writer.push(message)));
  });
  await Promise.all(promises);
}, "Test that promise is rejected with SyntaxError if NDEFMessageSource contains\
 invalid records.");

nfc_test(async (t, mockNFC) => {
  const writer = new NDEFWriter();
  const controller = new AbortController();

  //Make sure push is pending
  mockNFC.setPendingPushCompleted(false);
  const p = writer.push(test_text_data,
      { signal: controller.signal, timeout: 100 });
  const rejected = promise_rejects(t, 'AbortError', p);
  let callback_called = false;
  await new Promise(resolve => {
    t.step_timeout(() => {
      callback_called = true;
      controller.abort();
      resolve();
    }, 10);
  });
  await rejected;
  assert_true(callback_called, 'timeout should have caused the abort');
}, "NDEFWriter.push should fail if abort push request before push happends.");

</script>
